============================= test session starts =============================
platform win32 -- Python 3.14.0, pytest-9.0.1, pluggy-1.6.0 -- C:\Users\Andrei\Documents\qa-portfolio\automation-exercise-project\venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\Andrei\Documents\qa-portfolio\automation-exercise-project
collecting ... collected 5 items

tests/test_login.py::test_successful_login FAILED                        [ 20%]
tests/test_login.py::test_login_failures[test_portfolio_cz@yopmail.com-wrong_password123-Your email or password is incorrect!] PASSED [ 40%]
tests/test_login.py::test_login_failures[definitely_not_registered_2025@yopmail.com-any_pass-Your email or password is incorrect!] FAILED [ 60%]
tests/test_login.py::test_login_failures[' OR 1=1 ---any_pass-Your email or password is incorrect!] FAILED [ 80%]
tests/test_login.py::test_login_failures[  test_portfolio_cz@yopmail.com  -password123-Your email or password is incorrect!] FAILED [100%]

================================== FAILURES ===================================
____________________________ test_successful_login ____________________________

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000143CCA52120>
conn = <urllib3.connection.HTTPConnection object at 0x00000143CCA52510>
method = 'POST'
url = '/session/5ed9864f81a9e13286365538c657a77a/element/f.13994B3A80825EF0B09A90420FB9FC9F.d.3BD0C043E6E555E47BCC86E937C71D46.e.39/click'
body = '{}'
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.38.0 (python win32)', 'Connection': 'keep-alive'})
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
timeout = Timeout(connect=120, read=120, total=None), chunked = False
response_conn = None, preload_content = True, decode_content = True
enforce_content_length = True

    def _make_request(
        self,
        conn: BaseHTTPConnection,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | None = None,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        chunked: bool = False,
        response_conn: BaseHTTPConnection | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        enforce_content_length: bool = True,
    ) -> BaseHTTPResponse:
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param response_conn:
            Set this to ``None`` if you will handle releasing the connection or
            set the connection to have the response release it.
    
        :param preload_content:
          If True, the response's body will be preloaded during construction.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param enforce_content_length:
            Enforce content length checking. Body returned by server must match
            value of Content-Length header, if present. Otherwise, raise error.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
    
        try:
            # Trigger any extra validation we need to do.
            try:
                self._validate_conn(conn)
            except (SocketTimeout, BaseSSLError) as e:
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
                raise
    
        # _validate_conn() starts the connection to an HTTPS proxy
        # so we need to wrap errors with 'ProxyError' here too.
        except (
            OSError,
            NewConnectionError,
            TimeoutError,
            BaseSSLError,
            CertificateError,
            SSLError,
        ) as e:
            new_e: Exception = e
            if isinstance(e, (BaseSSLError, CertificateError)):
                new_e = SSLError(e)
            # If the connection didn't successfully connect to it's proxy
            # then there
            if isinstance(
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
            raise new_e
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            conn.request(
                method,
                url,
                body=body,
                headers=headers,
                chunked=chunked,
                preload_content=preload_content,
                decode_content=decode_content,
                enforce_content_length=enforce_content_length,
            )
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            pass
        except OSError as e:
            # MacOS/Linux
            # EPROTOTYPE and ECONNRESET are needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        if not conn.is_closed:
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, f"Read timed out. (read timeout={read_timeout})"
                )
            conn.timeout = read_timeout
    
        # Receive the response from the server
        try:
>           response = conn.getresponse()
                       ^^^^^^^^^^^^^^^^^^

venv\Lib\site-packages\urllib3\connectionpool.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\urllib3\connection.py:565: in getresponse
    httplib_response = super().getresponse()
                       ^^^^^^^^^^^^^^^^^^^^^
..\..\..\AppData\Local\Programs\Python\Python314\Lib\http\client.py:1430: in getresponse
    response.begin()
..\..\..\AppData\Local\Programs\Python\Python314\Lib\http\client.py:331: in begin
    version, status, reason = self._read_status()
                              ^^^^^^^^^^^^^^^^^^^
..\..\..\AppData\Local\Programs\Python\Python314\Lib\http\client.py:292: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <socket.SocketIO object at 0x00000143CC5013C0>
b = <memory at 0x00000143CC9C1B40>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        try:
>           return self._sock.recv_into(b)
                   ^^^^^^^^^^^^^^^^^^^^^^^
E           TimeoutError: timed out

..\..\..\AppData\Local\Programs\Python\Python314\Lib\socket.py:725: TimeoutError

The above exception was the direct cause of the following exception:

driver = <selenium.webdriver.chrome.webdriver.WebDriver (session="5ed9864f81a9e13286365538c657a77a")>

    def test_successful_login(driver):
        login_page = LoginPage(driver)
        driver.get("https://automationexercise.com/login")
        login_page.dismiss_consent()
    
        print("Attempting successful login...")
        # Clean usage: We know exactly where VALID_USER comes from.
>       login_page.login(config.VALID_USER, config.VALID_PASSWORD)

tests\test_login.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
pages\login_page.py:25: in login
    self.click(self.LOGIN_BTN)
pages\base_page.py:15: in click
    self.find(locator).click()
venv\Lib\site-packages\selenium\webdriver\remote\webelement.py:119: in click
    self._execute(Command.CLICK_ELEMENT)
venv\Lib\site-packages\selenium\webdriver\remote\webelement.py:572: in _execute
    return self._parent.execute(command, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\remote\webdriver.py:455: in execute
    response = cast(RemoteConnection, self.command_executor).execute(driver_command, params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\remote\remote_connection.py:407: in execute
    return self._request(command_info[0], url, body=data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\remote\remote_connection.py:431: in _request
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\urllib3\_request_methods.py:143: in request
    return self.request_encode_body(
venv\Lib\site-packages\urllib3\_request_methods.py:278: in request_encode_body
    return self.urlopen(method, url, **extra_kw)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\urllib3\poolmanager.py:459: in urlopen
    response = conn.urlopen(method, u.request_uri, **kw)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
venv\Lib\site-packages\urllib3\util\retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\urllib3\util\util.py:39: in reraise
    raise value
venv\Lib\site-packages\urllib3\connectionpool.py:787: in urlopen
    response = self._make_request(
venv\Lib\site-packages\urllib3\connectionpool.py:536: in _make_request
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000143CCA52120>
err = TimeoutError('timed out')
url = '/session/5ed9864f81a9e13286365538c657a77a/element/f.13994B3A80825EF0B09A90420FB9FC9F.d.3BD0C043E6E555E47BCC86E937C71D46.e.39/click'
timeout_value = 120

    def _raise_timeout(
        self,
        err: BaseSSLError | OSError | SocketTimeout,
        url: str,
        timeout_value: _TYPE_TIMEOUT | None,
    ) -> None:
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, f"Read timed out. (read timeout={timeout_value})"
            ) from err
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=56450): Read timed out. (read timeout=120)

venv\Lib\site-packages\urllib3\connectionpool.py:367: ReadTimeoutError
---------------------------- Captured stdout setup ----------------------------

[Setup] Starting Chrome...
---------------------------- Captured stdout call -----------------------------
Consent dialog dismissed.
Attempting successful login...
-------------------------- Captured stdout teardown ---------------------------

[Teardown] Closing browser...
---------------------------- Captured log teardown ----------------------------
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56450): Read timed out. (read timeout=120)")': /session/5ed9864f81a9e13286365538c657a77a
_ test_login_failures[definitely_not_registered_2025@yopmail.com-any_pass-Your email or password is incorrect!] _

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000143CCB351D0>
conn = <urllib3.connection.HTTPConnection object at 0x00000143CC9EB230>
method = 'POST', url = '/session/9877b10cff7404ff4aa8ef61aa9972db/element'
body = '{"using": "xpath", "value": "//p[text()=\'Your email or password is incorrect!\']"}'
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.38.0 (python win32)', 'Connection': 'keep-alive'})
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
timeout = Timeout(connect=120, read=120, total=None), chunked = False
response_conn = None, preload_content = True, decode_content = True
enforce_content_length = True

    def _make_request(
        self,
        conn: BaseHTTPConnection,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | None = None,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        chunked: bool = False,
        response_conn: BaseHTTPConnection | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        enforce_content_length: bool = True,
    ) -> BaseHTTPResponse:
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param response_conn:
            Set this to ``None`` if you will handle releasing the connection or
            set the connection to have the response release it.
    
        :param preload_content:
          If True, the response's body will be preloaded during construction.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param enforce_content_length:
            Enforce content length checking. Body returned by server must match
            value of Content-Length header, if present. Otherwise, raise error.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
    
        try:
            # Trigger any extra validation we need to do.
            try:
                self._validate_conn(conn)
            except (SocketTimeout, BaseSSLError) as e:
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
                raise
    
        # _validate_conn() starts the connection to an HTTPS proxy
        # so we need to wrap errors with 'ProxyError' here too.
        except (
            OSError,
            NewConnectionError,
            TimeoutError,
            BaseSSLError,
            CertificateError,
            SSLError,
        ) as e:
            new_e: Exception = e
            if isinstance(e, (BaseSSLError, CertificateError)):
                new_e = SSLError(e)
            # If the connection didn't successfully connect to it's proxy
            # then there
            if isinstance(
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
            raise new_e
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            conn.request(
                method,
                url,
                body=body,
                headers=headers,
                chunked=chunked,
                preload_content=preload_content,
                decode_content=decode_content,
                enforce_content_length=enforce_content_length,
            )
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            pass
        except OSError as e:
            # MacOS/Linux
            # EPROTOTYPE and ECONNRESET are needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        if not conn.is_closed:
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, f"Read timed out. (read timeout={read_timeout})"
                )
            conn.timeout = read_timeout
    
        # Receive the response from the server
        try:
>           response = conn.getresponse()
                       ^^^^^^^^^^^^^^^^^^

venv\Lib\site-packages\urllib3\connectionpool.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\urllib3\connection.py:565: in getresponse
    httplib_response = super().getresponse()
                       ^^^^^^^^^^^^^^^^^^^^^
..\..\..\AppData\Local\Programs\Python\Python314\Lib\http\client.py:1430: in getresponse
    response.begin()
..\..\..\AppData\Local\Programs\Python\Python314\Lib\http\client.py:331: in begin
    version, status, reason = self._read_status()
                              ^^^^^^^^^^^^^^^^^^^
..\..\..\AppData\Local\Programs\Python\Python314\Lib\http\client.py:292: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <socket.SocketIO object at 0x00000143CCA5F610>
b = <memory at 0x00000143CC9C3E80>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        try:
>           return self._sock.recv_into(b)
                   ^^^^^^^^^^^^^^^^^^^^^^^
E           TimeoutError: timed out

..\..\..\AppData\Local\Programs\Python\Python314\Lib\socket.py:725: TimeoutError

The above exception was the direct cause of the following exception:

driver = <selenium.webdriver.chrome.webdriver.WebDriver (session="9877b10cff7404ff4aa8ef61aa9972db")>
email = 'definitely_not_registered_2025@yopmail.com', password = 'any_pass'
expected_error = 'Your email or password is incorrect!'

    @pytest.mark.parametrize("email, password, expected_error", LOGIN_TEST_DATA)
    def test_login_failures(driver, email, password, expected_error):
        login_page = LoginPage(driver)
    
        driver.get("https://automationexercise.com/login")
        login_page.dismiss_consent()
    
        print(f"Testing login failure with: {email}")
        login_page.login(email, password)
    
>       actual_error = login_page.get_login_error_message()
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_login.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
pages\login_page.py:31: in get_login_error_message
    return self.find(self.LOGIN_ERROR_MESSAGE).text
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pages\base_page.py:12: in find
    return self.wait.until(EC.element_to_be_clickable(locator))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\support\wait.py:129: in until
    value = method(self._driver)
            ^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\support\expected_conditions.py:624: in _predicate
    target = driver.find_element(*target)  # grab element at locator
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\remote\webdriver.py:926: in find_element
    return self.execute(Command.FIND_ELEMENT, {"using": by, "value": value})["value"]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\remote\webdriver.py:455: in execute
    response = cast(RemoteConnection, self.command_executor).execute(driver_command, params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\remote\remote_connection.py:407: in execute
    return self._request(command_info[0], url, body=data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\remote\remote_connection.py:431: in _request
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\urllib3\_request_methods.py:143: in request
    return self.request_encode_body(
venv\Lib\site-packages\urllib3\_request_methods.py:278: in request_encode_body
    return self.urlopen(method, url, **extra_kw)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\urllib3\poolmanager.py:459: in urlopen
    response = conn.urlopen(method, u.request_uri, **kw)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
venv\Lib\site-packages\urllib3\util\retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\urllib3\util\util.py:39: in reraise
    raise value
venv\Lib\site-packages\urllib3\connectionpool.py:787: in urlopen
    response = self._make_request(
venv\Lib\site-packages\urllib3\connectionpool.py:536: in _make_request
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000143CCB351D0>
err = TimeoutError('timed out')
url = '/session/9877b10cff7404ff4aa8ef61aa9972db/element', timeout_value = 120

    def _raise_timeout(
        self,
        err: BaseSSLError | OSError | SocketTimeout,
        url: str,
        timeout_value: _TYPE_TIMEOUT | None,
    ) -> None:
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, f"Read timed out. (read timeout={timeout_value})"
            ) from err
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=56847): Read timed out. (read timeout=120)

venv\Lib\site-packages\urllib3\connectionpool.py:367: ReadTimeoutError
---------------------------- Captured stdout setup ----------------------------

[Setup] Starting Chrome...
---------------------------- Captured stdout call -----------------------------
Consent dialog dismissed.
Testing login failure with: definitely_not_registered_2025@yopmail.com
-------------------------- Captured stdout teardown ---------------------------

[Teardown] Closing browser...
---------------------------- Captured log teardown ----------------------------
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56847): Read timed out. (read timeout=120)")': /session/9877b10cff7404ff4aa8ef61aa9972db
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56847): Read timed out. (read timeout=120)")': /session/9877b10cff7404ff4aa8ef61aa9972db
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56847): Read timed out. (read timeout=120)")': /session/9877b10cff7404ff4aa8ef61aa9972db
_ test_login_failures[' OR 1=1 ---any_pass-Your email or password is incorrect!] _

driver = <selenium.webdriver.chrome.webdriver.WebDriver (session="1a26b2409991604bdc21bbeefbb04c80")>
email = "' OR 1=1 --", password = 'any_pass'
expected_error = 'Your email or password is incorrect!'

    @pytest.mark.parametrize("email, password, expected_error", LOGIN_TEST_DATA)
    def test_login_failures(driver, email, password, expected_error):
        login_page = LoginPage(driver)
    
        driver.get("https://automationexercise.com/login")
        login_page.dismiss_consent()
    
        print(f"Testing login failure with: {email}")
        login_page.login(email, password)
    
>       actual_error = login_page.get_login_error_message()
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_login.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
pages\login_page.py:31: in get_login_error_message
    return self.find(self.LOGIN_ERROR_MESSAGE).text
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pages\base_page.py:12: in find
    return self.wait.until(EC.element_to_be_clickable(locator))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <selenium.webdriver.support.wait.WebDriverWait (session="1a26b2409991604bdc21bbeefbb04c80")>
method = <function element_to_be_clickable.<locals>._predicate at 0x00000143CCAC7270>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        -----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       Symbols not available. Dumping unresolved backtrace:
E       	0x7ff6756da235
E       	0x7ff675432630
E       	0x7ff6751c16dd
E       	0x7ff67521a27e
E       	0x7ff67521a58c
E       	0x7ff67526ed77
E       	0x7ff67526baba
E       	0x7ff67520b0ed
E       	0x7ff67520bf63
E       	0x7ff675705d60
E       	0x7ff6756ffe8a
E       	0x7ff675721005
E       	0x7ff67544d71e
E       	0x7ff675454e1f
E       	0x7ff67543b7c4
E       	0x7ff67543b97f
E       	0x7ff6754218e8
E       	0x7ffab2657374
E       	0x7ffab3cfcc91

venv\Lib\site-packages\selenium\webdriver\support\wait.py:138: TimeoutException
---------------------------- Captured stdout setup ----------------------------

[Setup] Starting Chrome...
---------------------------- Captured stdout call -----------------------------
Consent dialog dismissed.
Testing login failure with: ' OR 1=1 --
-------------------------- Captured stdout teardown ---------------------------

[Teardown] Closing browser...
_ test_login_failures[  test_portfolio_cz@yopmail.com  -password123-Your email or password is incorrect!] _

driver = <selenium.webdriver.chrome.webdriver.WebDriver (session="bc3a97b12cbc95d1acf97762a3537d67")>
email = '  test_portfolio_cz@yopmail.com  ', password = 'password123'
expected_error = 'Your email or password is incorrect!'

    @pytest.mark.parametrize("email, password, expected_error", LOGIN_TEST_DATA)
    def test_login_failures(driver, email, password, expected_error):
        login_page = LoginPage(driver)
    
        driver.get("https://automationexercise.com/login")
        login_page.dismiss_consent()
    
        print(f"Testing login failure with: {email}")
        login_page.login(email, password)
    
>       actual_error = login_page.get_login_error_message()
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_login.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
pages\login_page.py:31: in get_login_error_message
    return self.find(self.LOGIN_ERROR_MESSAGE).text
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pages\base_page.py:12: in find
    return self.wait.until(EC.element_to_be_clickable(locator))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <selenium.webdriver.support.wait.WebDriverWait (session="bc3a97b12cbc95d1acf97762a3537d67")>
method = <function element_to_be_clickable.<locals>._predicate at 0x00000143CCF44A90>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        -----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       Symbols not available. Dumping unresolved backtrace:
E       	0x7ff6756da235
E       	0x7ff675432630
E       	0x7ff6751c16dd
E       	0x7ff67521a27e
E       	0x7ff67521a58c
E       	0x7ff67526ed77
E       	0x7ff67526baba
E       	0x7ff67520b0ed
E       	0x7ff67520bf63
E       	0x7ff675705d60
E       	0x7ff6756ffe8a
E       	0x7ff675721005
E       	0x7ff67544d71e
E       	0x7ff675454e1f
E       	0x7ff67543b7c4
E       	0x7ff67543b97f
E       	0x7ff6754218e8
E       	0x7ffab2657374
E       	0x7ffab3cfcc91

venv\Lib\site-packages\selenium\webdriver\support\wait.py:138: TimeoutException
---------------------------- Captured stdout setup ----------------------------

[Setup] Starting Chrome...
---------------------------- Captured stdout call -----------------------------
Consent dialog dismissed.
Testing login failure with:   test_portfolio_cz@yopmail.com  
-------------------------- Captured stdout teardown ---------------------------

[Teardown] Closing browser...
=========================== short test summary info ===========================
FAILED tests/test_login.py::test_successful_login - urllib3.exceptions.ReadTi...
FAILED tests/test_login.py::test_login_failures[definitely_not_registered_2025@yopmail.com-any_pass-Your email or password is incorrect!]
FAILED tests/test_login.py::test_login_failures[' OR 1=1 ---any_pass-Your email or password is incorrect!]
FAILED tests/test_login.py::test_login_failures[  test_portfolio_cz@yopmail.com  -password123-Your email or password is incorrect!]
=================== 4 failed, 1 passed in 857.00s (0:14:17) ===================
